import path from "node:path";

interface FileDesc {
  path: string;
  description: string;
}

interface DirNode {
  name: string;
  files: FileDesc[];
  children: Map<string, DirNode>;
}

export function generateMap(
  descriptions: Map<string, string>,
  repoName: string,
  pending: string[] = []
): string {
  const files: FileDesc[] = [];
  for (const [filePath, description] of descriptions) {
    files.push({ path: filePath, description });
  }

  // Sort files for deterministic output
  files.sort((a, b) => a.path.localeCompare(b.path));

  // Build directory tree
  const root = buildTree(files);

  // Generate markdown
  const lines: string[] = [];

  // Header
  lines.push(`# Context Map: ${repoName}`);
  lines.push("");
  lines.push(`> Generated by [ai-cartographer](https://github.com/gilpaAI/ai-cartographer)`);
  lines.push(`> ${new Date().toISOString()} | ${files.length} files indexed`);
  lines.push("");

  // Generate sections from top-level directories
  const sections = categorizeSections(root);

  for (const [sectionName, node] of sections) {
    lines.push(`## ${sectionName}`);
    lines.push("");
    renderNode(node, "", lines);
    lines.push("");
  }

  // Root-level files (not in any directory)
  if (root.files.length > 0) {
    lines.push("## Root");
    lines.push("");
    for (const file of root.files) {
      lines.push(`- \`${file.path}\` — ${file.description}`);
    }
    lines.push("");
  }

  // Pending files
  if (pending.length > 0) {
    lines.push("## Pending Analysis");
    lines.push("");
    for (const p of pending) {
      lines.push(`- \`${p}\` — _awaiting analysis_`);
    }
    lines.push("");
  }

  return lines.join("\n");
}

function buildTree(files: FileDesc[]): DirNode {
  const root: DirNode = { name: "", files: [], children: new Map() };

  for (const file of files) {
    const parts = file.path.split("/");
    let current = root;

    for (let i = 0; i < parts.length - 1; i++) {
      const dirName = parts[i];
      if (!current.children.has(dirName)) {
        current.children.set(dirName, {
          name: dirName,
          files: [],
          children: new Map(),
        });
      }
      current = current.children.get(dirName)!;
    }

    current.files.push(file);
  }

  return root;
}

function categorizeSections(root: DirNode): Map<string, DirNode> {
  const sections = new Map<string, DirNode>();

  const SECTION_NAMES: Record<string, string> = {
    src: "Source",
    lib: "Library",
    app: "Application",
    api: "API",
    test: "Tests",
    tests: "Tests",
    __tests__: "Tests",
    spec: "Tests",
    docs: "Documentation",
    doc: "Documentation",
    scripts: "Scripts",
    config: "Configuration",
    configs: "Configuration",
    public: "Public Assets",
    static: "Static Assets",
    assets: "Assets",
    migrations: "Database Migrations",
    cmd: "Commands",
    internal: "Internal",
    pkg: "Packages",
    packages: "Packages",
    components: "Components",
    pages: "Pages",
    routes: "Routes",
    middleware: "Middleware",
    utils: "Utilities",
    helpers: "Helpers",
    services: "Services",
    models: "Models",
    types: "Types",
    hooks: "Hooks",
  };

  for (const [dirName, node] of root.children) {
    const sectionName = SECTION_NAMES[dirName] ?? capitalize(dirName);
    sections.set(sectionName, node);
  }

  return sections;
}

function renderNode(
  node: DirNode,
  prefix: string,
  lines: string[]
): void {
  // Render files in this directory
  for (const file of node.files) {
    const filename = path.basename(file.path);
    lines.push(`- \`${prefix}${filename}\` — ${file.description}`);
  }

  // Render subdirectories
  for (const [dirName, child] of node.children) {
    const childPrefix = prefix ? `${prefix}${dirName}/` : `${dirName}/`;
    const fileCount = countFiles(child);

    if (fileCount <= 3) {
      // Inline small directories
      renderNode(child, childPrefix, lines);
    } else {
      // Section for larger directories
      lines.push(`- **${childPrefix}** (${fileCount} files)`);
      renderNode(child, childPrefix, lines);
    }
  }
}

function countFiles(node: DirNode): number {
  let count = node.files.length;
  for (const child of node.children.values()) {
    count += countFiles(child);
  }
  return count;
}

function capitalize(s: string): string {
  return s.charAt(0).toUpperCase() + s.slice(1);
}
